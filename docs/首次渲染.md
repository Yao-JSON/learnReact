## 首次渲染

`React`组件渲染的过程相对来说是复杂的多，在`15.0.0`之前`React`渲染的总入口是`React.renderComponent`，渲染大致流程；
![React.renderComponet](https://cdn.nlark.com/yuque/0/2019/png/96328/1547909092927-0ff80ab3-2ec2-40fd-91b8-4eb24eed252e.png)


```jsx
const ReactDOM = {
  render(
    element: React$Element<any>,
    container: DOMContainer,
    callback: ?Function,
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    );
  }
}
```

在`15.0.0`之后都是`React.render`，`render(component, container)`负责将一个`componet`实例渲染到给定的`container`。`React`框架在进行渲染时，会尽可能地复用现有的`DOM`节点，因此，`React`会先判断，当前的`container`是否存在与之对应的，已经渲染过的`Componet`，具体渲染过程请往下阅读。

#### 首次渲染

假设我们有一个`HelloWord`组件，返回的节点是 `<div>hello world</div>`这样一个标签。

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const HelloWorld = <div>hello World</div>

ReactDOM.render(HelloWorld, document.getElementById('root'));
```

`React`的渲染入口是 `React.render`，所以我们就从`render`入手，来分析`React 16`的组件渲染流程。

##### render

`render`方法是`react-dom`对外暴露的一个API，该方法只会进行一次整体更新，在第一次渲染后，会将`DOMElement`用`ReactComponent`的实例所替换。方法有返回值，且是同步的返回值，返回值是我们跟组件的实例。


```jsx
render(element: React$Element<any>, container: DOMContainer,callback: ?Function) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    );
  }

```

#### legacyRenderSubtreeIntoContainer

`legacyRenderSubtreeIntoContainer`的主要作用是将`ReactElement`渲染到`container`；初始化根节点`ReactRoot`，添加到 `container._reactRootContainer`上去。

```js

type Root = {
  render(children: ReactNodeList, callback: ?() => mixed): Work,
  unmount(callback: ?() => mixed): Work,
  legacy_renderSubtreeIntoContainer(
    parentComponent: ?React$Component<any, any>,
    children: ReactNodeList,
    callback: ?() => mixed,
  ): Work,
  createBatch(): Batch,

  _internalRoot: FiberRoot,
};

function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  // 获取 ReactRoot contaienr
  let root: Root = (container._reactRootContainer: any);
  if (!root) {
    // 创建 _reactRootContainer 参考 ReactRoot 部分
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    unbatchedUpdates(() => {
      if (parentComponent != null) {
        root.legacy_renderSubtreeIntoContainer(
          parentComponent,
          children,
          callback,
        );
      } else {
        root.render(children, callback);
      }
    });
  } else {
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    if (parentComponent != null) {
      root.legacy_renderSubtreeIntoContainer(
        parentComponent,
        children,
        callback,
      );
    } else {
      root.render(children, callback);
    }
  }
  return getPublicRootInstance(root._internalRoot);
}
```

###### ReactRoot Vs ReactWork



源码截取
```js

function ReactWork() {
  this._callbacks = null;
  this._didCommit = false;
  this._onCommit = this._onCommit.bind(this);
}

ReactWork.prototype.then = function(onCommit: () => mixed): void {
  if (this._didCommit) {
    onCommit();
    return;
  }
  let callbacks = this._callbacks;
  if (callbacks === null) {
    callbacks = this._callbacks = [];
  }
  callbacks.push(onCommit);
};

ReactWork.prototype._onCommit = function(): void {
  if (this._didCommit) {
    return;
  }
  this._didCommit = true;
  const callbacks = this._callbacks;
  if (callbacks === null) {
    return;
  }
  // TODO: Error handling.
  for (let i = 0; i < callbacks.length; i++) {
    const callback = callbacks[i];
    callback();
  }
};

function ReactRoot(
  container: Container,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  // createContainer 会创建一个 Fiber 节点，也就是 React 真正意义上的虚拟节点
  const root = createContainer(container, isConcurrent, hydrate);
  this._internalRoot = root;
}

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() => mixed,
): Work {
  const root = this._internalRoot;
  const work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, null, work._onCommit);
  return work;
};

ReactRoot.prototype.unmount = function(callback: ?() => mixed): Work {
  const root = this._internalRoot;
  const work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(null, root, null, work._onCommit);
  return work;
};



```

###### ReactRoot.prototype.render

`ReactRoot.render`主要作用是将`ReactCompoent`子节点递归渲染在根节点下。源码如下：

```js

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() => mixed,
): Work {
  const root = this._internalRoot;
  const work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, null, work._onCommit);
  return work;
};

// updateContainer 仅仅是做了一个透传

```

###### updateContainer

`updateContainer`仅仅是做了一个透传，




